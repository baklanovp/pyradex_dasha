!    -*- f90 -*-
! Note: the context of this file is case sensitive.

subroutine matrix(niter,conv) ! in matrix.f
    use mradexinc
    integer :: niter
    logical :: conv
end subroutine matrix
function escprob(tau) ! in matrix.f
    use mradexinc
    real*8 :: tau
    real*8 :: escprob
end function escprob
subroutine ludcmp(a,n,np,indx,d) ! in slatec.f
    double precision dimension(np,np) :: a
    integer, optional,check(shape(indx, 0) == n),depend(indx) :: n=shape(indx, 0)
    integer, optional,check(shape(a, 0) == np),depend(a) :: np=shape(a, 0)
    integer dimension(n) :: indx
    double precision :: d
end subroutine ludcmp
subroutine lubksb(a,n,np,indx,b) ! in slatec.f
    double precision dimension(np,np) :: a
    integer :: n
    integer, optional,check(shape(a, 0) == np),depend(a) :: np=shape(a, 0)
    integer dimension(np),depend(np) :: indx
    double precision dimension(np),depend(np) :: b
end subroutine lubksb
subroutine sgeir(a,lda,n,v,itask,ind,work,iwork) ! in slatec.f
    double precision dimension(lda,*) :: a
    integer, optional,check(shape(a, 0) == lda),depend(a) :: lda=shape(a, 0)
    integer, optional,check(shape(work, 0) == n),depend(work) :: n=shape(work, 0)
    double precision dimension(*) :: v
    integer :: itask
    integer :: ind
    double precision dimension(n,*) :: work
    integer dimension(*) :: iwork
end subroutine sgeir
function r1mach(i) ! in slatec.f
    integer :: i
    double precision :: r1mach
end function r1mach
function sasum(n,sx,incx) ! in slatec.f
    integer :: n
    double precision dimension(*) :: sx
    integer :: incx
    double precision :: sasum
end function sasum
subroutine scopy(n,sx,incx,sy,incy) ! in slatec.f
    integer :: n
    double precision dimension(*) :: sx
    integer :: incx
    double precision dimension(*) :: sy
    integer :: incy
end subroutine scopy
function sdsdot(n,sb,sx,incx,sy,incy) ! in slatec.f
    integer :: n
    double precision :: sb
    double precision dimension(*) :: sx
    integer :: incx
    double precision dimension(*) :: sy
    integer :: incy
    double precision :: sdsdot
end function sdsdot
subroutine sgefa(a,lda,n,ipvt,info) ! in slatec.f
    double precision dimension(lda,*) :: a
    integer, optional,check(shape(a, 0) == lda),depend(a) :: lda=shape(a, 0)
    integer :: n
    integer dimension(*) :: ipvt
    integer :: info
end subroutine sgefa
function isamax(n,sx,incx) ! in slatec.f
    integer :: n
    double precision dimension(*) :: sx
    integer :: incx
    integer :: isamax
end function isamax
subroutine saxpy(n,sa,sx,incx,sy,incy) ! in slatec.f
    integer :: n
    double precision :: sa
    double precision dimension(*) :: sx
    integer :: incx
    double precision dimension(*) :: sy
    integer :: incy
end subroutine saxpy
subroutine sscal(n,sa,sx,incx) ! in slatec.f
    integer :: n
    double precision :: sa
    double precision dimension(*) :: sx
    integer :: incx
end subroutine sscal
subroutine sgesl(a,lda,n,ipvt,b,job) ! in slatec.f
    double precision dimension(lda,*) :: a
    integer, optional,check(shape(a, 0) == lda),depend(a) :: lda=shape(a, 0)
    integer :: n
    integer dimension(*) :: ipvt
    double precision dimension(*) :: b
    integer :: job
end subroutine sgesl
function sdot(n,sx,incx,sy,incy) ! in slatec.f
    integer :: n
    double precision dimension(*) :: sx
    integer :: incx
    double precision dimension(*) :: sy
    integer :: incy
    double precision :: sdot
end function sdot
subroutine xermsg(librar,subrou,messg,nerr,level) ! in slatec.f
    character*(*) :: librar
    character*(*) :: subrou
    character*(*) :: messg
    integer :: nerr
    integer :: level
end subroutine xermsg
function j4save(iwhich,ivalue,iset) ! in slatec.f
    integer :: iwhich
    integer :: ivalue
    logical :: iset
    integer :: j4save
end function j4save
subroutine xercnt(librar,subrou,messg,nerr,level,kontrl) ! in slatec.f
    character*(*) :: librar
    character*(*) :: subrou
    character*(*) :: messg
    integer :: nerr
    integer :: level
    integer :: kontrl
end subroutine xercnt
subroutine xerhlt(messg) ! in slatec.f
    character*(*) :: messg
end subroutine xerhlt
subroutine xerprn(prefix,npref,messg,nwrap) ! in slatec.f
    character*(*) :: prefix
    integer :: npref
    character*(*) :: messg
    integer :: nwrap
end subroutine xerprn
function i1mach(i) ! in slatec.f
    integer :: i
    integer :: i1mach
end function i1mach
subroutine xgetua(iunita,n) ! in slatec.f
    integer dimension(5) :: iunita
    integer :: n
end subroutine xgetua
subroutine xersve(librar,subrou,messg,kflag,nerr,level,icount) ! in slatec.f
    character*(*) :: librar
    character*(*) :: subrou
    character*(*) :: messg
    integer :: kflag
    integer :: nerr
    integer :: level
    integer :: icount
end subroutine xersve
subroutine fdump ! in slatec.f
end subroutine fdump
subroutine backrad ! in background.f
    use mradexinc
end subroutine backrad
subroutine galbr ! in background.f
    use mradexinc
end subroutine galbr
subroutine splcoeff(x,f,n,fp1,fpn,fpp) ! in background.f
    real*8 dimension(2500) :: x
    real*8 dimension(2500) :: f
    integer :: n
    real*8 :: fp1
    real*8 :: fpn
    real*8 dimension(2500) :: fpp
end subroutine splcoeff
subroutine splintrp(xin,fin,fppin,n,x,fout) ! in background.f
    real*8 dimension(n) :: xin
    real*8 dimension(n),depend(n) :: fin
    real*8 dimension(n),depend(n) :: fppin
    integer, optional,check(shape(xin, 0) == n),depend(xin) :: n=shape(xin, 0)
    real*8 :: x
    real*8 :: fout
end subroutine splintrp
subroutine getinputs ! in io.f
    use mradexinc
end subroutine getinputs
subroutine defaults ! in io.f
    use mradexinc
end subroutine defaults
function length(str) ! in io.f
    character*200 :: str
    integer :: length
end function length
subroutine output(niter) ! in io.f
    use mradexinc
    integer :: niter
end subroutine output
subroutine readdata ! in readdata.f
    use mradexinc
end subroutine readdata
module mradexinc ! in mRadexInc.f90
    character*120 :: outfile
    character*120 :: molfile
    character*120 :: specref
    character(len=120), parameter,optional :: radat='./data/'
    character(len=20), parameter,optional :: version='30nov2011'
    character(len=*), parameter,optional :: logfile='./radex.log'
    integer, parameter,optional :: method=1
    real*8, parameter,optional :: clight=2.99792458d10
    real*8, parameter,optional :: hplanck=6.6260963d-27
    real*8, parameter,optional :: kboltz=1.3806505d-16
    real*8, parameter,optional :: pi=3.14159265d0
    real*8, parameter,optional :: amu=1.67262171d-24
    integer, parameter,optional :: maxpart=9
    integer, parameter,optional :: maxtemp=99
    integer, parameter,optional :: maxlev=2999
    integer, parameter,optional :: maxline=99999
    integer, parameter,optional :: maxcoll=99999
    integer :: nlev
    integer :: nline
    integer :: ncoll
    integer :: npart
    integer :: ntemp
    integer dimension(99999) :: iupp
    integer dimension(99999) :: ilow
    real*8 :: amass
    real*8 dimension(2999) :: eterm
    real*8 dimension(2999) :: gstat
    real*8 dimension(99999) :: aeinst
    real*8 dimension(99999) :: eup
    real*8 dimension(9) :: density
    real*8 :: tkin
    real*8 :: tbg
    real*8 :: cdmol
    real*8 :: deltav
    real*8 :: totdens
    integer, parameter,optional :: miniter=10
    integer, parameter,optional :: maxiter=9999
    real*8 :: fmin
    real*8 :: fmax
    real*8, parameter,optional :: ccrit=1e-06
    real*8, parameter,optional :: eps=1.0d-30
    real*8, parameter,optional :: minpop=1.0d-20
    real*8 dimension(99999) :: taul
    real*8 dimension(99999) :: tex
    real*8 dimension(99999) :: backi
    real*8 dimension(99999) :: xnu
    real*8 dimension(99999) :: trj
    real*8 dimension(99999) :: totalb
    real*8 dimension(99999) :: spfreq
    character*6 dimension(2999) :: qnum
    real*8, parameter,optional,depend(clight,hplanck,kboltz) :: fk=4.0
    real*8, parameter,optional,depend(clight,hplanck) :: thc=2.d0*hplanck*clight
    real*8, parameter,optional,depend(pi) :: fgaus=34.064
    real*8 dimension(2999) :: ctot
    real*8 dimension(2999,2999) :: crate
    real*8 dimension(2999) :: xpop
    logical :: debug
end module mradexinc

! This file was auto-generated with f2py (version:2.1.3).
! See:
! https://web.archive.org/web/20140822061353/http://cens.ioc.ee/projects/f2py2e
