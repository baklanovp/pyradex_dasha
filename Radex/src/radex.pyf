!    -*- f90 -*-
! Note: the context of this file is case sensitive.

subroutine readdata ! in old_readdata.f
    use mradexinc
end subroutine readdata
subroutine matrix(niter,conv) ! in old_matrix.f
    use mradexinc
    integer :: niter
    logical :: conv
end subroutine matrix
function escprob(tau) ! in old_matrix.f
    use mradexinc
    real*8 :: tau
    real*8 :: escprob
end function escprob
subroutine ludcmp(a,n,np,indx,d) ! in old_slatec.f
    double precision dimension(np,np) :: a
    integer, optional,check(shape(indx, 0) == n),depend(indx) :: n=shape(indx, 0)
    integer, optional,check(shape(a, 0) == np),depend(a) :: np=shape(a, 0)
    integer dimension(n) :: indx
    double precision :: d
end subroutine ludcmp
subroutine lubksb(a,n,np,indx,b) ! in old_slatec.f
    double precision dimension(np,np) :: a
    integer :: n
    integer, optional,check(shape(a, 0) == np),depend(a) :: np=shape(a, 0)
    integer dimension(np),depend(np) :: indx
    double precision dimension(np),depend(np) :: b
end subroutine lubksb
subroutine sgeir(a,lda,n,v,itask,ind,work,iwork) ! in old_slatec.f
    double precision dimension(lda,*) :: a
    integer, optional,check(shape(a, 0) == lda),depend(a) :: lda=shape(a, 0)
    integer, optional,check(shape(work, 0) == n),depend(work) :: n=shape(work, 0)
    double precision dimension(*) :: v
    integer :: itask
    integer :: ind
    double precision dimension(n,*) :: work
    integer dimension(*) :: iwork
end subroutine sgeir
function r1mach(i) ! in old_slatec.f
    integer :: i
    double precision :: r1mach
end function r1mach
function sasum(n,sx,incx) ! in old_slatec.f
    integer :: n
    double precision dimension(*) :: sx
    integer :: incx
    double precision :: sasum
end function sasum
subroutine scopy(n,sx,incx,sy,incy) ! in old_slatec.f
    integer :: n
    double precision dimension(*) :: sx
    integer :: incx
    double precision dimension(*) :: sy
    integer :: incy
end subroutine scopy
function sdsdot(n,sb,sx,incx,sy,incy) ! in old_slatec.f
    integer :: n
    double precision :: sb
    double precision dimension(*) :: sx
    integer :: incx
    double precision dimension(*) :: sy
    integer :: incy
    double precision :: sdsdot
end function sdsdot
subroutine sgefa(a,lda,n,ipvt,info) ! in old_slatec.f
    double precision dimension(lda,*) :: a
    integer, optional,check(shape(a, 0) == lda),depend(a) :: lda=shape(a, 0)
    integer :: n
    integer dimension(*) :: ipvt
    integer :: info
end subroutine sgefa
function isamax(n,sx,incx) ! in old_slatec.f
    integer :: n
    double precision dimension(*) :: sx
    integer :: incx
    integer :: isamax
end function isamax
subroutine saxpy(n,sa,sx,incx,sy,incy) ! in old_slatec.f
    integer :: n
    double precision :: sa
    double precision dimension(*) :: sx
    integer :: incx
    double precision dimension(*) :: sy
    integer :: incy
end subroutine saxpy
subroutine sscal(n,sa,sx,incx) ! in old_slatec.f
    integer :: n
    double precision :: sa
    double precision dimension(*) :: sx
    integer :: incx
end subroutine sscal
subroutine sgesl(a,lda,n,ipvt,b,job) ! in old_slatec.f
    double precision dimension(lda,*) :: a
    integer, optional,check(shape(a, 0) == lda),depend(a) :: lda=shape(a, 0)
    integer :: n
    integer dimension(*) :: ipvt
    double precision dimension(*) :: b
    integer :: job
end subroutine sgesl
function sdot(n,sx,incx,sy,incy) ! in old_slatec.f
    integer :: n
    double precision dimension(*) :: sx
    integer :: incx
    double precision dimension(*) :: sy
    integer :: incy
    double precision :: sdot
end function sdot
subroutine xermsg(librar,subrou,messg,nerr,level) ! in old_slatec.f
    character*(*) :: librar
    character*(*) :: subrou
    character*(*) :: messg
    integer :: nerr
    integer :: level
end subroutine xermsg
function j4save(iwhich,ivalue,iset) ! in old_slatec.f
    integer :: iwhich
    integer :: ivalue
    logical :: iset
    integer :: j4save
end function j4save
subroutine xercnt(librar,subrou,messg,nerr,level,kontrl) ! in old_slatec.f
    character*(*) :: librar
    character*(*) :: subrou
    character*(*) :: messg
    integer :: nerr
    integer :: level
    integer :: kontrl
end subroutine xercnt
subroutine xerhlt(messg) ! in old_slatec.f
    character*(*) :: messg
end subroutine xerhlt
subroutine xerprn(prefix,npref,messg,nwrap) ! in old_slatec.f
    character*(*) :: prefix
    integer :: npref
    character*(*) :: messg
    integer :: nwrap
end subroutine xerprn
function i1mach(i) ! in old_slatec.f
    integer :: i
    integer :: i1mach
end function i1mach
subroutine xgetua(iunita,n) ! in old_slatec.f
    integer dimension(5) :: iunita
    integer :: n
end subroutine xgetua
subroutine xersve(librar,subrou,messg,kflag,nerr,level,icount) ! in old_slatec.f
    character*(*) :: librar
    character*(*) :: subrou
    character*(*) :: messg
    integer :: kflag
    integer :: nerr
    integer :: level
    integer :: icount
end subroutine xersve
subroutine fdump ! in old_slatec.f
end subroutine fdump
subroutine backrad ! in old_background.f
    use mradexinc
end subroutine backrad
subroutine getinputs ! in old_io.f
    use mradexinc
end subroutine getinputs
subroutine output(niter) ! in old_io.f
    use mradexinc
    integer :: niter
end subroutine output
subroutine matrix(niter,conv) ! in matrix.f90
    use mradexinc
    integer :: niter
    logical :: conv
end subroutine matrix
function escprob(tau) ! in matrix.f90
    use mradexinc
    real*8 :: tau
    real*8 :: escprob
end function escprob
module io ! in io.f90
    use mradexinc
    subroutine getinputs ! in io.f90:io
    end subroutine getinputs
    subroutine output(niter) ! in io.f90:io
        use mradexinc
        integer :: niter
    end subroutine output
end module io
module background ! in background.f90
    use mradexinc
    subroutine backrad ! in background.f90:background
    end subroutine backrad
end module background
subroutine readdata ! in readdata.f90
    use mradexinc
end subroutine readdata
subroutine ludcmp(a,n,np,indx,d) ! in slatec.f90
    double precision dimension(np,np) :: a
    integer, optional,check(shape(indx, 0) == n),depend(indx) :: n=shape(indx, 0)
    integer, optional,check(shape(a, 0) == np),depend(a) :: np=shape(a, 0)
    integer dimension(n) :: indx
    double precision :: d
end subroutine ludcmp
subroutine lubksb(a,n,np,indx,b) ! in slatec.f90
    double precision dimension(np,np) :: a
    integer :: n
    integer, optional,check(shape(a, 0) == np),depend(a) :: np=shape(a, 0)
    integer dimension(np),depend(np) :: indx
    double precision dimension(np),depend(np) :: b
end subroutine lubksb
subroutine sgeir(a,lda,n,v,itask,ind,work,iwork) ! in slatec.f90
    double precision dimension(lda,*) :: a
    integer, optional,check(shape(a, 0) == lda),depend(a) :: lda=shape(a, 0)
    integer, optional,check(shape(work, 0) == n),depend(work) :: n=shape(work, 0)
    double precision dimension(*) :: v
    integer :: itask
    integer :: ind
    double precision dimension(n,*) :: work
    integer dimension(*) :: iwork
end subroutine sgeir
function r1mach(i) ! in slatec.f90
    integer :: i
    double precision :: r1mach
end function r1mach
function sasum(n,sx,incx) ! in slatec.f90
    integer :: n
    double precision dimension(*) :: sx
    integer :: incx
    double precision :: sasum
end function sasum
subroutine scopy(n,sx,incx,sy,incy) ! in slatec.f90
    integer :: n
    double precision dimension(*) :: sx
    integer :: incx
    double precision dimension(*) :: sy
    integer :: incy
end subroutine scopy
function sdsdot(n,sb,sx,incx,sy,incy) ! in slatec.f90
    integer :: n
    double precision :: sb
    double precision dimension(*) :: sx
    integer :: incx
    double precision dimension(*) :: sy
    integer :: incy
    double precision :: sdsdot
end function sdsdot
subroutine sgefa(a,lda,n,ipvt,info) ! in slatec.f90
    double precision dimension(lda,*) :: a
    integer, optional,check(shape(a, 0) == lda),depend(a) :: lda=shape(a, 0)
    integer :: n
    integer dimension(*) :: ipvt
    integer :: info
end subroutine sgefa
function isamax(n,sx,incx) ! in slatec.f90
    integer :: n
    double precision dimension(*) :: sx
    integer :: incx
    integer :: isamax
end function isamax
subroutine saxpy(n,sa,sx,incx,sy,incy) ! in slatec.f90
    integer :: n
    double precision :: sa
    double precision dimension(*) :: sx
    integer :: incx
    double precision dimension(*) :: sy
    integer :: incy
end subroutine saxpy
subroutine sscal(n,sa,sx,incx) ! in slatec.f90
    integer :: n
    double precision :: sa
    double precision dimension(*) :: sx
    integer :: incx
end subroutine sscal
subroutine sgesl(a,lda,n,ipvt,b,job) ! in slatec.f90
    double precision dimension(lda,*) :: a
    integer, optional,check(shape(a, 0) == lda),depend(a) :: lda=shape(a, 0)
    integer :: n
    integer dimension(*) :: ipvt
    double precision dimension(*) :: b
    integer :: job
end subroutine sgesl
function sdot(n,sx,incx,sy,incy) ! in slatec.f90
    integer :: n
    double precision dimension(*) :: sx
    integer :: incx
    double precision dimension(*) :: sy
    integer :: incy
    double precision :: sdot
end function sdot
subroutine xermsg(librar,subrou,messg,nerr,level) ! in slatec.f90
    character*(*) intent(in) :: librar
    character*(*) intent(in) :: subrou
    character*(*) intent(in) :: messg
    integer :: nerr
    integer :: level
end subroutine xermsg
function j4save(iwhich,ivalue,iset) ! in slatec.f90
    integer :: iwhich
    integer :: ivalue
    logical :: iset
    integer :: j4save
end function j4save
subroutine xercnt(librar,subrou,messg,nerr,level,kontrl) ! in slatec.f90
    character*(*) :: librar
    character*(*) :: subrou
    character*(*) :: messg
    integer :: nerr
    integer :: level
    integer :: kontrl
end subroutine xercnt
subroutine xerhlt(messg) ! in slatec.f90
    character*(*) :: messg
end subroutine xerhlt
subroutine xerprn(prefix,npref,messg,nwrap) ! in slatec.f90
    character*(*) :: prefix
    integer :: npref
    character*(*) :: messg
    integer :: nwrap
end subroutine xerprn
function i1mach(i) ! in slatec.f90
    integer :: i
    integer :: i1mach
end function i1mach
subroutine xgetua(iunita,n) ! in slatec.f90
    integer dimension(5) :: iunita
    integer :: n
end subroutine xgetua
subroutine xersve(librar,subrou,messg,kflag,nerr,level,icount) ! in slatec.f90
    character*(*) intent(in) :: librar
    character*(*) intent(in) :: subrou
    character*(*) intent(in) :: messg
    integer :: kflag
    integer :: nerr
    integer :: level
    integer :: icount
end subroutine xersve
subroutine fdump ! in slatec.f90
end subroutine fdump
module cla ! in cla.f90
    integer, parameter,optional :: isp=selected_int_kind(8)
    integer, parameter,optional :: sp=selected_real_kind(6, 30)
    integer, parameter,optional :: dp=selected_real_kind(14, 200)
    integer(kind=4), parameter,public,optional :: strlen=120
    integer(kind=4), parameter,public,optional :: xstrlen=256
    integer(kind=4), parameter,optional :: cla_int=1
    integer(kind=4), parameter,optional :: cla_float=2
    integer(kind=4), parameter,optional :: cla_char=3
    integer(kind=4), parameter,optional :: cla_xchar=4
    integer(kind=4), parameter,optional :: cla_logical=5
    integer(kind=4), parameter,optional :: cla_flag=6
    character(len=120) dimension(6) :: cla_kindstr
    character(len=120), private :: cla_empty
    character(len=120) dimension(6) :: cla_true_str
    type(cla_t), pointer,private,dimension(:) :: cla_registry
    integer(kind=4), private :: cla_num
    type cla_t ! in cla.f90:cla
        character(len=strlen) :: key
        character(len=xstrlen) :: description
        integer(kind=isp) :: kind
        character(len=strlen) :: default_bn
    end type cla_t
    interface cla_get ! in cla.f90:cla
    end interface cla_get
    subroutine cla_init ! in cla.f90:cla
    end subroutine cla_init
    subroutine cla_register(key,description,kkind,default_bn) ! in cla.f90:cla
        character*(*) :: key
        character*(*) :: description
        integer(kind=isp) :: kkind
        character*(*) :: default_bn
    end subroutine cla_register
    subroutine cla_show ! in cla.f90:cla
    end subroutine cla_show
    subroutine cla_help ! in cla.f90:cla
    end subroutine cla_help
    function cla_eq(str1,str2) ! in cla.f90:cla
        character*(*) intent(in) :: str1
        character*(*) intent(in) :: str2
        integer, pure :: cla_eq
    end function cla_eq
    function cla_str_eq(str1,str2) ! in cla.f90:cla
        character*(*) intent(in) :: str1
        character*(*) intent(in) :: str2
        logical, pure :: cla_str_eq
    end function cla_str_eq
    subroutine cla_validate ! in cla.f90:cla
    end subroutine cla_validate
    function cla_key_present(key) ! in cla.f90:cla
        character*(*) :: key
        logical :: cla_key_present
    end function cla_key_present
    subroutine cla_get_char(key,value) ! in cla.f90:cla
        character*(*) intent(in) :: key
        character*strlen intent(out) :: value
    end subroutine cla_get_char
    subroutine cla_get_float_r4(key,float_value) ! in cla.f90:cla
        character*(*) :: key
        real(kind=sp) :: float_value
    end subroutine cla_get_float_r4
    subroutine cla_get_float_r8(key,float_value) ! in cla.f90:cla
        character*(*) :: key
        real(kind=dp) :: float_value
    end subroutine cla_get_float_r8
    subroutine cla_get_int_i4(key,int_value) ! in cla.f90:cla
        character*(*) :: key
        integer(kind=4) :: int_value
    end subroutine cla_get_int_i4
    subroutine cla_get_int_i8(key,int_value) ! in cla.f90:cla
        character*(*) :: key
        integer(kind=dp) :: int_value
    end subroutine cla_get_int_i8
    subroutine cla_get_logical(key,logical_value) ! in cla.f90:cla
        character*(*) :: key
        logical :: logical_value
    end subroutine cla_get_logical
    subroutine cla_get_flag(key,logical_value) ! in cla.f90:cla
        character*(*) :: key
        logical :: logical_value
    end subroutine cla_get_flag
end module cla
module mradexinc ! in mRadexInc.f90
    character*120 :: outfile
    character*120 :: molfile
    character*120 :: specref
    character(len=120), parameter,optional :: radat='./data/'
    character(len=20), parameter,optional :: version='30nov2011'
    character(len=*), parameter,optional :: logfile='./radex.log'
    integer, parameter,optional :: method=1
    real*8, parameter,optional :: clight=2.99792458d10
    real*8, parameter,optional :: hplanck=6.6260963d-27
    real*8, parameter,optional :: kboltz=1.3806505d-16
    real*8, parameter,optional :: pi=3.14159265d0
    real*8, parameter,optional :: amu=1.67262171d-24
    integer, parameter,optional :: maxpart=9
    integer, parameter,optional :: maxtemp=99
    integer, parameter,optional :: maxlev=2999
    integer, parameter,optional :: maxline=99999
    integer, parameter,optional :: maxcoll=99999
    integer :: nlev
    integer :: nline
    integer :: ncoll
    integer :: npart
    integer :: ntemp
    integer dimension(99999) :: iupp
    integer dimension(99999) :: ilow
    real*8 :: amass
    real*8 dimension(2999) :: eterm
    real*8 dimension(2999) :: gstat
    real*8 dimension(99999) :: aeinst
    real*8 dimension(99999) :: eup
    real*8 dimension(9) :: density
    real*8 :: tkin
    real*8 :: tbg
    real*8 :: cdmol
    real*8 :: deltav
    real*8 :: totdens
    integer, parameter,optional :: miniter=10
    integer, parameter,optional :: maxiter=9999
    real*8 :: fmin
    real*8 :: fmax
    real*8, parameter,optional :: ccrit=1e-06
    real*8, parameter,optional :: eps=1.0d-30
    real*8, parameter,optional :: minpop=1.0d-20
    real*8 dimension(99999) :: taul
    real*8 dimension(99999) :: tex
    real*8 dimension(99999) :: backi
    real*8 dimension(99999) :: xnu
    real*8 dimension(99999) :: trj
    real*8 dimension(99999) :: totalb
    real*8 dimension(99999) :: spfreq
    character*6 dimension(2999) :: qnum
    real*8, parameter,optional,depend(clight,hplanck,kboltz) :: fk=4.0
    real*8, parameter,optional,depend(clight,hplanck) :: thc=2.d0*hplanck*clight
    real*8, parameter,optional,depend(pi) :: fgaus=34.064
    real*8 dimension(2999) :: ctot
    real*8 dimension(2999,2999) :: crate
    real*8 dimension(2999) :: xpop
    logical :: is_debug
end module mradexinc

! This file was auto-generated with f2py (version:2.1.3).
! See:
! https://web.archive.org/web/20140822061353/http://cens.ioc.ee/projects/f2py2e
